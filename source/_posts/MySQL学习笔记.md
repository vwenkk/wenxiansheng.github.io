---
title: "MySQL学习笔记"
date: 2018-03-15 22:45:30
tags:
- 学习笔记

categories:
- 数据库
    - MySQL
---
    
高性能MySQL读书笔记

<!-- more -->

## Mysql 架构与历史

### 并发控制

> 读写锁

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。

这两种类型的锁通常被称之为共享锁（shared lock）和排它锁（exclusive lock），也叫读锁（read lock） 和写锁（write lock）

读锁是共享的，多个客户可以在同一时刻同时读取同一资源，而互不干扰。

写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁



> 表锁（table lock）

表锁是Mysql中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。

一个用户对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对改表的所有读写操作

只有没有写锁时，其他读取的用户才能获取读锁，读锁之间是不相互阻塞的。

写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面

行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销），行级锁只在存储引擎层实现，mysql服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。



## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用改组查询的全部语句，那么就执行该组查询，如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说事务内的语句，要么全部执行成功，要么全部执行失败。

> ACID

- 原子性（atomicity）
    - 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性
- 一致性（consistency）
    - 数据库总是从一个一致性的状态转换到另外一个一致性的状态。
- 隔离性（isolation）
    - 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
- 持久性（durability）
    - 一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。



> 事务什么时候开启

使用begin语句之后实际上并没有开启一个事务，对数据进行增删改等操作后才开启了一个事务

```sql
SELECT * FROM information_schema.INNODB_TRX # 查询当前正在执行中的事务
```

#### 不可重复读和幻读的区别

不可重复读重点在于update和delete，而幻读的重点在于insert

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其他事务无法修改这些数据，就可以实现可重复读了。但是这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名奇妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复度、脏读等问题。

**不可重复度和幻读最大的区别就在于如何通过锁机制来解决他们产生的问题**

#### MVCC在Mysql中的InnoDB中的实现

在InnoDB中，主要是通过使用ReadView的技术来实现判断。查询出来的每一行记录，都会用readview来判断以下当前这行是否可以被当前事务看到，如果可以，则输出，否则就利用undolog来构建历史版本，再进行判断，直到记录构建到最老的版本或者可见性条件满足



在trx_sys中，一直维护一个全局的活跃的读写事务id（trx_sys->descriptors）, id 按照从小到大排序，表示在某个时间点，数据库中所有的活跃（已经开始但还没提交）的读写（必须是读写事务，只读事务不包含在内）事务。当需要一个一致性读写的时候（即创建新的readview），会把全局读写事务id拷贝一份到readview本地(read_view_t->descriptors)，当作当前事务的快照



当查询出一条记录后，记录上有一个trx_id，表示这条记录最后被修改时的事务id，可见性判断逻辑如下：

如果记录上的trx_id小于活跃事务id的最小值，说明这条记录的最后修改在readiview创建之前，因此这条记录可以被看见。

如果记录上的trx_id 大于等于活跃事务id的最大值，说明这条记录最后修改在readview之后，因此这条记录肯定不可以被看见。

如果记录上的trx_id在最小和最大之间，并且trx_id在活跃事务列表中，则这条记录的最后修改是在readview创建之中，被另外一个活跃事务所修改，所以这条记录也不可以被看见。

如果trx_id不在活跃事务id列表中，则表示这条记录的最后修改在readview创建之前，所以可以看到



基于上述判断如果记录不可见，则尝试使用undo去构建老的版本，直到找到可以被看见的记录或者解析完所有的undo

#### 隔离级别

sql标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低的隔离级别通常可以执行更高的并发，系统的开销也更低

- 读未提交（READ UNCOMMITED）
    - 在读未提交级别中，事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty read）
- 提交读（READ COMMITED）
    - 大多数数据库系统的默认隔离级别都是读提交（Mysql不是）。读提交满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。
- 可重复读（REPEATABLE READ）
    - ​	可重复读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上可重复读隔离级别无法解决另外一个幻读的问题。
    - 幻读：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题
    - 可重复读是MySql的默认事务隔离级别
- 可串行化（SERIALIZABLE）
    - 可串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。

## Schema与数据类型优化

#### BLOB 和 TEXT类型

Mysql 把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大的时候，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

Mysql 对BLOB和TEXT列进行排序和其他类型不同，它只对每个列的最前max_sort_length字节而不是整个字符串进行排序。

如果只需要排序前面一小部分字符，则可以减小max_sort_legth的配置。或者使用order by substring(column, length)

Mysql 不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

#### 磁盘临时表和文件排序

因为Memory引擎不支持BLOB和TEXT类型，所以如果查询使用了BLOB或TEXT列并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，即使只有几行数据也是如此。

最好尽量避免使用BLOB和TEXT类型。如果无法避免，可以在所有用到BLOB和TEXT字段的地方使用SUBSTRING(column， length) 将列值转换为字符串（order by ），这样就可以使用内存临时表了，但是要确保截取的字符串足够短，不会使临时表的大小超过max_heap_table_size 或 tmp_table_size，超过以后Mysql会将内存临时表转换为MyIsam磁盘临时表

#### 使用枚举（ENUM）代替字符串类型

可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。Mysql再内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”

`枚举字段是按照内部存储的整数而不是定义的字符进行排序的`

绕过这种限制的方式是按照需要的顺序来定义枚举列。另外也可以在查询中使用field（）函数显式的指定排序顺序

```sql
select e from enum_test order by field (e, 'aa', 'bb', 'cc')
```

#### 日期和时间类型

- DATETIME
    - 这个类型能保存大范围的值，从1001年到9999年，精度为秒。把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关使用8字节存储
- TIMESTAMP
    - 这个类型保存了从1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和UNIX时间戳相同，使用4字节存储
    - 默认情况下，如果插入时没有指定第一个timestamp列的值，MySql则设置这个列的值为当前时间。默认timestamp列为not null

通常应该尽量使用timestamp，它比datetime空间效率更高

#### 选择标识符

> 整数类型

整数通常时标识列的最好选择，因为他们很快并且可以使用auto_increment

> 字符串类型

- 如果可能应该避免使用字符串作为标识列，因为他们很消耗空间，并且通常比数字类型满，尤其是MyISAM表使用字符串作为标识列时要特别小心，MyISAM默认对字符串使用压缩索引，会导致查询慢很多。
- 因为插入值会随机地写到索引的不同位置，索引使得insert语句更慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片
- select语句会变得很慢，因为逻辑上相邻的行为会分布在磁盘和内存的不同地方
- 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。



## 高性能索引

索引是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能。



#### B-Tree索引

使用‘B-Tree’数据结构来存储数据，底层的存储引擎可能使用不同的存储结构如：InnoDB使用的是B+Tree

B-Tree索引使用于全键值、键值范围或键值前缀查找，其中键前缀查找只适用与最左前缀的查找
```sql
CREATE TABLE People
(
    last_name  varchar(50)      not null,
    first_name varchar(50)      not null,
    dob        date             not null,
    gender     enum (' m', 'f') not null,
    key (last_name, first_name, dob)
);
```
- 全值匹配
    - 全值匹配值的是和索引中的所有列进行匹配，如：上面的索引可用与查找姓名为Cuba Allen、 出生于 1960- 01- 01 的 人
- 匹配最左前缀
    - 前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列
- 匹配列前缀
    - 也可以只匹配某一列的值的开头部分。如：前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了所有的第一列
- 匹配范围值
    - 如前面提到的索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。
- 精确匹配某一列并范围匹配另一列
    - 前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头的人。即第一列last_name全匹配，第二列first_name范围匹配
- 只访问索引的查询（索引覆盖）
    - B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引。无需访问数据行（无需回表）

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的Order bu 操作

一本来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果ORDER BY子句满足前面列出的几种查询类类型，则这个索引也可以满足对应的排序需求

B-Tree的一些限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。如：上面的例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，业务发查找姓以某个字母结尾的人
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。如：查询 WHERE last_ name=' Smith' AND frst_ name LIKE 'J％' AND dob=' 1976- 12- 23' 这个查询只能使用索引的前两列，因为这里的like是一个范围条件（如果范围查询数量有限可以那么 可以 通过 使用 多个 等于 条件 来 代替 范围 条件 ）

#### 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。

因为索引自身只需存储对应的哈希值，索引索引的结构十分紧凑，这也让哈希索引查找的速度非常快。

哈希索引的限制：

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行（索引覆盖），不过访问内存中的行速度很快，所以大部分情况下对性能影响并不明显。
- 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序
- 哈希索引也不支持部分索引匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。如：在（A，B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
- 哈希索引只支持等值比较查询，包括=、IN、<=> (注意<>和<=> 是不同的操作)。也不支持任何范围查询 如：where price > 100
- 访问哈希索引的数据非常快，除非有很多哈希冲突
- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高



#### 空间数据索引

MyISAM表支持空间索引，可以用作地理数据存储。

#### 全文索引

全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。

#### 索引的优点

1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机IO变为顺序IO

#### 高性能索引策略

> 独立的列

如果查询中的列不是独立的，Mysql就不会使用索引，“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数

如：下面的这个查询就无法使用actor_id的索引

```sql
SELECT actor_ id FROM sakila. actor WHERE actor_ id + 1 = 5;
```

> 前缀索引和索引选择性

有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约空间，从而提高索引效率。但这样也会降低索引的选择性。



索引选择性是指，不重复的索引值和数据表记录总数的比值。索引的选择性越高，则查询效率越高，因为选择性高的索引可以让Mysql过滤掉更多的行。



计算合适的前缀长度的一个办法是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。



前缀索引是一种能使索引更小、更快的有效方法，但另一方面也有缺点，MySql无法使用前缀索引做Order by 和 group by， 也无法使用前缀索引做覆盖扫描。

#### 聚簇索引

聚簇索引不是一个单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式。但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，他的数据行实际上存放在索引的叶子页中。

因为无法同时把数据行放在两个不同的地方，所以一个表只能有一个聚簇索引

![image-20210528115057532](http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20210528115057532.png)

叶子页包含了行的全部数据，但是节点也只包含了索引列。

InnoDB将通过主键聚集数据。

如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，Innodb会隐式定义一个主键来作为聚簇索引。

聚簇索引的优点：

- 可以把相关数据保存在一起
- 数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取
- 使用覆盖索引扫描的查询时可以直接使用页节点中的主键值。

聚簇索引的确定：

- 插入速度严重依赖于插入顺序。如果按照主键的顺序插入是加载数据到InnoDB中速度最快的方式。如果不是按照主键顺序加载数据，那么在加载完成之后，最好用OPTIMIZE TABLE 命令重新组织下表
- 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间
- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者页分裂导致数据存储不连续的时候
- 二级索引可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列
- 二级索引访问需要两次索引查找，而不是一次

#### InnoDB中按主键顺序插入的优缺点

优点:

- 因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。避免了大量的页分裂和碎片

缺点：

- 对于高并发工作负载，在InnoDB中按照顺序插入可能会造成明显的争用。主键上的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制。

