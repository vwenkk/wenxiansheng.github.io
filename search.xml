<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RocketMQ学习笔记</title>
    <url>/2022/06/15/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>  一种提供消息队列服务的中间件，是一套提供了消息生产、存储、消费全过程API的软件系统。消息即数据，一般消息的体量不会很大。<br>主要用途为限流削峰、异步处理、服务解耦。</p>
<span id="more"></span>

<h5 id="1、MQ-简介"><a href="#1、MQ-简介" class="headerlink" title="1、MQ 简介"></a>1、MQ 简介</h5><p>一种提供消息队列服务的中间件，是一套提供了消息生产、存储、消费全过程API的软件系统。消息即数据，一般消息的体量不会很大</p>
<h5 id="2、用途"><a href="#2、用途" class="headerlink" title="2、用途"></a>2、用途</h5><p><strong>限流削峰</strong></p>
<p>MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮</p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220330211205452.png" alt="image-20220330211205452"></p>
<p><strong>异步处理</strong></p>
<p>上游系统对下游系统的调用如果为同步调用，会大大降低系统的吞吐量和并发度，异步调用会解决这些问题。所有两层之间若要实现同步到异步的转化，一般做法就是在这两层之间添加一个MQ层。</p>
<p><strong>服务解耦</strong></p>
<h5 id="3、MQ选择"><a href="#3、MQ选择" class="headerlink" title="3、MQ选择"></a>3、MQ选择</h5><p>中间件的考量维度：可靠性，性能，功能，可运维行，可拓展性，是否开源及社区活跃度</p>
<p><strong>rabbitmq：</strong></p>
<p>优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置</p>
<p>缺点：性能和吞吐量较差，不易进行二次开发</p>
<p><strong>rocketmq：</strong></p>
<p>优点：性能好，稳定可靠，有活跃的中文社区，特点响应快</p>
<p>缺点：兼容性较差，但随意影响力的扩大，该问题会有改善</p>
<p><strong>kafka：</strong></p>
<p>优点：拥有强大的性能及吞吐量，兼容性很好</p>
<p>缺点：由于“攒一波再处理”导致延迟比较高</p>
<p><strong>pulsar：</strong> 采用存储和计算分离的设计，是消息队里产品中黑马，值得持续关</p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220330213904530.png" alt="image-20220330213904530"></p>
<h3 id="二、RocketMQ-概述"><a href="#二、RocketMQ-概述" class="headerlink" title="二、RocketMQ 概述"></a>二、RocketMQ 概述</h3><h5 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h5><p>RocketMQ是一个统一消息引擎、轻量级数据处理平台。</p>
<p>是阿里巴巴开源的消息中间件。2016年11月28日，阿里巴巴向Apache基金会捐赠该项目。2017年9月25，成为Apache顶级项目。</p>
<h5 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h5><p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220330223452188.png" alt="image-20220330223452188"></p>
<p><strong>消息模型</strong></p>
<p>RocketMQ主要由Producer、Broker、Consumer三部分组成，其中Producer负责生产消息、Consumer负责消费消息、Broker负责存储消息。Broker在实际部署中对应一天服务器，每个Broker可以存储多个Topic的消息，每个Topic可以分片存储于不同的Broker。</p>
<p><strong>队列</strong></p>
<p>Message Queue用于存储消息的物理地址。每个Topic中的消息地址 存储在多个MessageQueue中。ConsumerGroup由多个Consumer实例构成</p>
<p><strong>消息生产者</strong></p>
<p>Producer 负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<p><strong>消息消费者（Consumer）</strong></p>
<p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<p><strong>代理服务器（Broker Server）</strong></p>
<p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<p><strong>名字服务（Name Server）</strong></p>
<p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<p><strong>拉取式消费（Pull Consumer）</strong></p>
<p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<p><strong>推动式消费（Push Consumer）</strong></p>
<p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<p><strong>生产者组（Producer Group）</strong></p>
<p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p><strong>消费者组（Consumer Group）</strong></p>
<p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<p><strong>集群消费</strong>（Clustering）</p>
<p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<p><strong>广播消费</strong>（Broadcasting）</p>
<p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<p><strong>普通顺序消息</strong>（Normal Ordered Message）</p>
<p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<p><strong>严格顺序消息（Strictly Ordered Message）</strong></p>
<p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<p><strong>消息</strong></p>
<p>消息是指消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的MessageID，可以携带具有业务标识的Key。系统提供了通过MessageId和Key查询消息的功能。</p>
<p><strong>主题</strong></p>
<p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是进行消息订阅的基本单位i</p>
<p><strong>标签</strong></p>
<p>为消息设置的标志，用以同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不用业务目的在同一主题下设置不同标签。标签能够有效保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同主题的不同消费逻辑，实现更好的扩展</p>
<h5 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h5><p>NameServer主要作用是为生产者和消费者提供关于Topic的路由信息</p>
<p>主要包括两个功能：</p>
<p>Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；</p>
<p>路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。</p>
<p>NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</p>
<p><strong>路由注册</strong></p>
<p>路由注册时通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer保持长连接，每隔30秒向所有的NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdateTimestamp，</p>
<p><strong>路由删除</strong></p>
<p>NameServer和Broker保持长连接，Broker状态存储在BrokerLiveTable里，NameServer会每10s扫描一次NameServer</p>
<p>一旦发现已经有120s没有收到Broker发送过来的心跳信息，就移除该Broker并关闭与Broker的连接，同时更新路由元信息。 还有一种情况是Broker正常关闭，会执行unRegisterBroker指令。</p>
<p><strong>路由发现</strong></p>
<p>路由发现并不是实时的，当Topic路由出现变化后，NameServer不主动推送给客户端。由客户端定时拉取Topic最新的路由</p>
<h5 id="3、特性"><a href="#3、特性" class="headerlink" title="3、特性"></a>3、特性</h5><p><strong>订阅发布</strong></p>
<p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据</p>
<p><strong>消息顺序</strong></p>
<p>消息有序是指一类消息消费时，能够按照发送的的顺序来消费。如：：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。</p>
<p>RocketMQ可以按照严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息。</p>
<p>全局顺序是指某个topic下的所有消息都要保证顺序，部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>全局顺序：对于指定的一个topic，所有消息按照严格的先入先出的顺序进行发布和消费。适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
<li>分区顺序：对于指定的一个Topic，所有消息根据sharding key进行区块分区。同一个分区消息按照严格先入先出顺序进行发布和消费。Sharding key是顺序消息中用来区分不同分区的关键字段，和普通消息的key完全不同的概念。用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li>
</ul>
<p><strong>消息过滤</strong></p>
<p>RocketMQ的消费者根据Tag进行消息过滤，支持自定义属性过滤。消息过滤目前是在Broker端实现的，优点是减少了Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p>
<p><strong>消息可靠性</strong></p>
<p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p>
<ol>
<li>Broker非正常关闭</li>
<li>Broker异常Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况</li>
<li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p>
<p><strong>至少一次</strong></p>
<p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p>
<p><strong>回溯消费</strong></p>
<p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p>
<p><strong>事务消息</strong></p>
<p>RocketMQ事务消息（Transactional Message）是指应用本地事物和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X&#x2F;Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致</p>
<p><strong>定时消息</strong></p>
<p>定时消息（延迟队列）是指消息发送broker后，不会立即被消费，等待特定时间投递给真正的topic。broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。</p>
<p>可以自定义messageDelayLevel。messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p>
<ul>
<li>level &#x3D;&#x3D; 0，消息为非延迟消息</li>
<li>1&lt;&#x3D;level&lt;&#x3D;maxLevel，消息延迟特定时间，例如level&#x3D;&#x3D;1，延迟1s</li>
<li>level &gt; maxLevel，则level&#x3D;&#x3D; maxLevel，例如level&#x3D;&#x3D;20，延迟2h</li>
</ul>
<p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId &#x3D; delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<p><strong>消息重试</strong></p>
<p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li>
<li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li>
</ul>
<p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<p><strong>消息重投</strong></p>
<p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p>
<ul>
<li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li>
<li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li>
<li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li>
</ul>
<p><strong>流量控制</strong></p>
<p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p>
<p>生产者流控：</p>
<ul>
<li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li>
<li>如果开启transientStorePoolEnable &#x3D;&#x3D; true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li>
<li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li>
<li>broker通过拒绝send 请求方式实现流量控制。</li>
</ul>
<p>注意，生产者流控，不会尝试消息重投。</p>
<p>消费者流控：</p>
<ul>
<li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li>
<li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li>
<li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li>
</ul>
<p>消费者流控的结果是降低拉取频率。</p>
<p><strong>死信队列</strong></p>
<p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动消息重试；达到最大重试次数后，如果消费依然失败，表明消费者在正常情况下无法正确的消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息，将存储死信消息的特殊队列称为死信队列。在RocketMQ中，可以通过console控制台对死信队列中的消息进行重发使得消费者实例再次进行消费。</p>
<h3 id="三、数据复制与刷盘策略"><a href="#三、数据复制与刷盘策略" class="headerlink" title="三、数据复制与刷盘策略"></a>三、数据复制与刷盘策略</h3><p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220403140959146.png" alt="image-20220403140959146"></p>
<h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>复制策略是Broker的Master与Slave之间的数据同步方式。分为同步复制和异步复制：</p>
<p>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回ACK</p>
<p>异步复制：消息写入master后，master立即向producer返回成功ACK，无须等待slave数据成功</p>
<h4 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h4><p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220404161605051.png" alt="image-20220404161605051"></p>
<p>同步刷盘：只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</p>
<p>异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p>
<h4 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h4><p>RocketMQ消息队列集群主要包括NameServer、Broker(Master&#x2F;Slave)、Producer、Consumer4个角色，基本通讯流程如下：</p>
<ol>
<li>Broker启动后需要完成一次将自己注册到NameServer的操作，随后每隔30s时间定时向NameServer上报Topic路由信息</li>
<li>消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有从NameServer上重新拉取路由信息。同时Producer会默认每隔30s向NameServer拉取一次路由信息</li>
<li>消息生产者根据路由信息选择一个队列进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</li>
<li>消费者根据路由信息，在完成客户端的负载均衡后，选择其中一个或某几个消息队列拉取消息并进行消费。</li>
</ol>
<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220404162721289.png" alt="image-20220404162721289"></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<ol>
<li><p>事务消息发送及提交：</p>
<p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）。</p>
</li>
<li><p>补偿流程：</p>
<p>(1) 对没有Commit&#x2F;Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
</li>
</ol>
<h3 id="四、工作原理"><a href="#四、工作原理" class="headerlink" title="四、工作原理"></a>四、工作原理</h3><h4 id="一、消息的生产"><a href="#一、消息的生产" class="headerlink" title="一、消息的生产"></a>一、消息的生产</h4><h5 id="消息的生产过程"><a href="#消息的生产过程" class="headerlink" title="消息的生产过程"></a>消息的生产过程</h5><p>Producer可以将消息写入到Broker中的某Queue中，经历了如下过程：</p>
<ul>
<li>Producer发送消息之前，会向NameServer发出获取消息Topic的路由信息请求</li>
<li>Namserver 返回该Topic的路由表和Broker列表</li>
<li>Producer根据代码中指定的Queue选择策略，从Queue列表中选择一个队列，用于后续存储消息</li>
<li>Producer对消息做一些特殊处理，如：消息超过4M，会对其进行压缩</li>
<li>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出Queue</li>
</ul>
<h5 id="Queue选择算法"><a href="#Queue选择算法" class="headerlink" title="Queue选择算法"></a>Queue选择算法</h5><p>对于无序消息，Queue选择算法（消息投递算法），常见的有两种：</p>
<p><strong>轮训算法</strong></p>
<p>默认选择算法，该算法保证了每个Queue中可以均匀的获取到消息</p>
<p><strong>最小投递延迟算法</strong></p>
<h5 id="二、消息存储"><a href="#二、消息存储" class="headerlink" title="二、消息存储"></a>二、消息存储</h5><p>abort：该文件在Broker启动后会自动创建，正常关闭Broker该文件会自动消失。若没有启动Broker的情况下，发现这个文件是存在的，说明之前Broker的关闭是非正常关闭。</p>
<p>checkpoint：存储commitlog、consumequeue、index文件的最后刷盘时间戳</p>
<p>commitlog：存储着commitlog文件、消息写在commitlog文件中</p>
<p>config：存放着Broker运行期间的一些配置数据</p>
<p>Consumerqueue：存放着consumerqueue文件，队列存放在这个目录中。</p>
<p>index：其中存放着消息索引文件indexFile</p>
<p>lock：运行期间使用到的全局资源锁</p>
<p><strong>Commitlog文件</strong></p>
<p>commitlog目录中存放很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件早打小为1G，文件名由20位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说，这些消息在Broker中存放时并没有被按照Topic进行分类存放</p>
<blockquote>
<p>mappedFile是顺序读写文件，访问效率很高</p>
</blockquote>
<p>为了提高效率，会为每个topic在~&#x2F;store&#x2F;consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个Topic的Queue建立一个目录，目录名为queueId。每个目录中存放若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。</p>
<p><strong>索引条目</strong></p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220404181640638.png" alt="image-20220404181640638"></p>
<p>每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量Commitlog Offset、消息长度、消息Tag的HashCode。</p>
<p><strong>消息单元</strong></p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20220404175556071.png" alt="image-20220404175556071"></p>
<p>mappedFIle文件内容由一个个消息单元构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息内容body、消息总长度BodyLength、消息主题topic、topic长度topicLength、消息生产者Bornhost、消息发送时间戳BornTimestamp、消息所在队列QueueId消息在Queueu中存储的偏移量QueueOffset等相关属性。</p>
]]></content>
      <categories>
        <category>MQ - RocketMQ</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2018/03/15/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>高性能MySQL读书笔记</p>
<span id="more"></span>

<h2 id="Mysql-架构与历史"><a href="#Mysql-架构与历史" class="headerlink" title="Mysql 架构与历史"></a>Mysql 架构与历史</h2><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><blockquote>
<p>读写锁</p>
</blockquote>
<p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。</p>
<p>这两种类型的锁通常被称之为共享锁（shared lock）和排它锁（exclusive lock），也叫读锁（read lock） 和写锁（write lock）</p>
<p>读锁是共享的，多个客户可以在同一时刻同时读取同一资源，而互不干扰。</p>
<p>写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁</p>
<blockquote>
<p>表锁（table lock）</p>
</blockquote>
<p>表锁是Mysql中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。</p>
<p>一个用户对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对改表的所有读写操作</p>
<p>只有没有写锁时，其他读取的用户才能获取读锁，读锁之间是不相互阻塞的。</p>
<p>写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面</p>
<p>行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销），行级锁只在存储引擎层实现，mysql服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用改组查询的全部语句，那么就执行该组查询，如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<blockquote>
<p>ACID</p>
</blockquote>
<ul>
<li>原子性（atomicity）<ul>
<li>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性</li>
</ul>
</li>
<li>一致性（consistency）<ul>
<li>数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li>
</ul>
</li>
<li>隔离性（isolation）<ul>
<li>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
</ul>
</li>
<li>持久性（durability）<ul>
<li>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</li>
</ul>
</li>
</ul>
<blockquote>
<p>事务什么时候开启</p>
</blockquote>
<p>使用begin语句之后实际上并没有开启一个事务，对数据进行增删改等操作后才开启了一个事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX # 查询当前正在执行中的事务</span><br></pre></td></tr></table></figure>

<h4 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h4><p>不可重复读重点在于update和delete，而幻读的重点在于insert</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其他事务无法修改这些数据，就可以实现可重复读了。但是这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名奇妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复度、脏读等问题。</p>
<p><strong>不可重复度和幻读最大的区别就在于如何通过锁机制来解决他们产生的问题</strong></p>
<h4 id="MVCC在Mysql中的InnoDB中的实现"><a href="#MVCC在Mysql中的InnoDB中的实现" class="headerlink" title="MVCC在Mysql中的InnoDB中的实现"></a>MVCC在Mysql中的InnoDB中的实现</h4><p>在InnoDB中，主要是通过使用ReadView的技术来实现判断。查询出来的每一行记录，都会用readview来判断以下当前这行是否可以被当前事务看到，如果可以，则输出，否则就利用undolog来构建历史版本，再进行判断，直到记录构建到最老的版本或者可见性条件满足</p>
<p>在trx_sys中，一直维护一个全局的活跃的读写事务id（trx_sys-&gt;descriptors）, id 按照从小到大排序，表示在某个时间点，数据库中所有的活跃（已经开始但还没提交）的读写（必须是读写事务，只读事务不包含在内）事务。当需要一个一致性读写的时候（即创建新的readview），会把全局读写事务id拷贝一份到readview本地(read_view_t-&gt;descriptors)，当作当前事务的快照</p>
<p>当查询出一条记录后，记录上有一个trx_id，表示这条记录最后被修改时的事务id，可见性判断逻辑如下：</p>
<p>如果记录上的trx_id小于活跃事务id的最小值，说明这条记录的最后修改在readiview创建之前，因此这条记录可以被看见。</p>
<p>如果记录上的trx_id 大于等于活跃事务id的最大值，说明这条记录最后修改在readview之后，因此这条记录肯定不可以被看见。</p>
<p>如果记录上的trx_id在最小和最大之间，并且trx_id在活跃事务列表中，则这条记录的最后修改是在readview创建之中，被另外一个活跃事务所修改，所以这条记录也不可以被看见。</p>
<p>如果trx_id不在活跃事务id列表中，则表示这条记录的最后修改在readview创建之前，所以可以看到</p>
<p>基于上述判断如果记录不可见，则尝试使用undo去构建老的版本，直到找到可以被看见的记录或者解析完所有的undo</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>sql标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低的隔离级别通常可以执行更高的并发，系统的开销也更低</p>
<ul>
<li>读未提交（READ UNCOMMITED）<ul>
<li>在读未提交级别中，事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty read）</li>
</ul>
</li>
<li>提交读（READ COMMITED）<ul>
<li>大多数数据库系统的默认隔离级别都是读提交（Mysql不是）。读提交满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</li>
</ul>
</li>
<li>可重复读（REPEATABLE READ）<ul>
<li>​	可重复读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上可重复读隔离级别无法解决另外一个幻读的问题。</li>
<li>幻读：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题</li>
<li>可重复读是MySql的默认事务隔离级别</li>
</ul>
</li>
<li>可串行化（SERIALIZABLE）<ul>
<li>可串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。</li>
</ul>
</li>
</ul>
<h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h4 id="BLOB-和-TEXT类型"><a href="#BLOB-和-TEXT类型" class="headerlink" title="BLOB 和 TEXT类型"></a>BLOB 和 TEXT类型</h4><p>Mysql 把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大的时候，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p>
<p>Mysql 对BLOB和TEXT列进行排序和其他类型不同，它只对每个列的最前max_sort_length字节而不是整个字符串进行排序。</p>
<p>如果只需要排序前面一小部分字符，则可以减小max_sort_legth的配置。或者使用order by substring(column, length)</p>
<p>Mysql 不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p>
<h4 id="磁盘临时表和文件排序"><a href="#磁盘临时表和文件排序" class="headerlink" title="磁盘临时表和文件排序"></a>磁盘临时表和文件排序</h4><p>因为Memory引擎不支持BLOB和TEXT类型，所以如果查询使用了BLOB或TEXT列并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，即使只有几行数据也是如此。</p>
<p>最好尽量避免使用BLOB和TEXT类型。如果无法避免，可以在所有用到BLOB和TEXT字段的地方使用SUBSTRING(column， length) 将列值转换为字符串（order by ），这样就可以使用内存临时表了，但是要确保截取的字符串足够短，不会使临时表的大小超过max_heap_table_size 或 tmp_table_size，超过以后Mysql会将内存临时表转换为MyIsam磁盘临时表</p>
<h4 id="使用枚举（ENUM）代替字符串类型"><a href="#使用枚举（ENUM）代替字符串类型" class="headerlink" title="使用枚举（ENUM）代替字符串类型"></a>使用枚举（ENUM）代替字符串类型</h4><p>可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。Mysql再内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”</p>
<p><code>枚举字段是按照内部存储的整数而不是定义的字符进行排序的</code></p>
<p>绕过这种限制的方式是按照需要的顺序来定义枚举列。另外也可以在查询中使用field（）函数显式的指定排序顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e <span class="keyword">from</span> enum_test <span class="keyword">order</span> <span class="keyword">by</span> field (e, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><ul>
<li>DATETIME<ul>
<li>这个类型能保存大范围的值，从1001年到9999年，精度为秒。把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关使用8字节存储</li>
</ul>
</li>
<li>TIMESTAMP<ul>
<li>这个类型保存了从1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和UNIX时间戳相同，使用4字节存储</li>
<li>默认情况下，如果插入时没有指定第一个timestamp列的值，MySql则设置这个列的值为当前时间。默认timestamp列为not null</li>
</ul>
</li>
</ul>
<p>通常应该尽量使用timestamp，它比datetime空间效率更高</p>
<h4 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h4><blockquote>
<p>整数类型</p>
</blockquote>
<p>整数通常时标识列的最好选择，因为他们很快并且可以使用auto_increment</p>
<blockquote>
<p>字符串类型</p>
</blockquote>
<ul>
<li>如果可能应该避免使用字符串作为标识列，因为他们很消耗空间，并且通常比数字类型满，尤其是MyISAM表使用字符串作为标识列时要特别小心，MyISAM默认对字符串使用压缩索引，会导致查询慢很多。</li>
<li>因为插入值会随机地写到索引的不同位置，索引使得insert语句更慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片</li>
<li>select语句会变得很慢，因为逻辑上相邻的行为会分布在磁盘和内存的不同地方</li>
<li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li>
</ul>
<h2 id="高性能索引"><a href="#高性能索引" class="headerlink" title="高性能索引"></a>高性能索引</h2><p>索引是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>使用‘B-Tree’数据结构来存储数据，底层的存储引擎可能使用不同的存储结构如：InnoDB使用的是B+Tree</p>
<p>B-Tree索引使用于全键值、键值范围或键值前缀查找，其中键前缀查找只适用与最左前缀的查找</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People</span><br><span class="line">(</span><br><span class="line">    last_name  <span class="type">varchar</span>(<span class="number">50</span>)      <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">50</span>)      <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    dob        <span class="type">date</span>             <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender     enum (<span class="string">&#x27; m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    key (last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>全值匹配<ul>
<li>全值匹配值的是和索引中的所有列进行匹配，如：上面的索引可用与查找姓名为Cuba Allen、 出生于 1960- 01- 01 的 人</li>
</ul>
</li>
<li>匹配最左前缀<ul>
<li>前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列</li>
</ul>
</li>
<li>匹配列前缀<ul>
<li>也可以只匹配某一列的值的开头部分。如：前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了所有的第一列</li>
</ul>
</li>
<li>匹配范围值<ul>
<li>如前面提到的索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。</li>
</ul>
</li>
<li>精确匹配某一列并范围匹配另一列<ul>
<li>前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头的人。即第一列last_name全匹配，第二列first_name范围匹配</li>
</ul>
</li>
<li>只访问索引的查询（索引覆盖）<ul>
<li>B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引。无需访问数据行（无需回表）</li>
</ul>
</li>
</ul>
<p>因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的Order bu 操作</p>
<p>一本来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果ORDER BY子句满足前面列出的几种查询类类型，则这个索引也可以满足对应的排序需求</p>
<p>B-Tree的一些限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。如：上面的例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，业务发查找姓以某个字母结尾的人</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。如：查询 WHERE last_ name&#x3D;’ Smith’ AND frst_ name LIKE ‘J％’ AND dob&#x3D;’ 1976- 12- 23’ 这个查询只能使用索引的前两列，因为这里的like是一个范围条件（如果范围查询数量有限可以那么 可以 通过 使用 多个 等于 条件 来 代替 范围 条件 ）</li>
</ul>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。</p>
<p>因为索引自身只需存储对应的哈希值，索引索引的结构十分紧凑，这也让哈希索引查找的速度非常快。</p>
<p>哈希索引的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行（索引覆盖），不过访问内存中的行速度很快，所以大部分情况下对性能影响并不明显。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序</li>
<li>哈希索引也不支持部分索引匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。如：在（A，B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。</li>
<li>哈希索引只支持等值比较查询，包括&#x3D;、IN、&lt;&#x3D;&gt; (注意&lt;&gt;和&lt;&#x3D;&gt; 是不同的操作)。也不支持任何范围查询 如：where price &gt; 100</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高</li>
</ul>
<h4 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h4><p>MyISAM表支持空间索引，可以用作地理数据存储。</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
<h4 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h4><ol>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机IO变为顺序IO</li>
</ol>
<h4 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h4><blockquote>
<p>独立的列</p>
</blockquote>
<p>如果查询中的列不是独立的，Mysql就不会使用索引，“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数</p>
<p>如：下面的这个查询就无法使用actor_id的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_ id <span class="keyword">FROM</span> sakila. actor <span class="keyword">WHERE</span> actor_ id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前缀索引和索引选择性</p>
</blockquote>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<p>索引选择性是指，不重复的索引值和数据表记录总数的比值。索引的选择性越高，则查询效率越高，因为选择性高的索引可以让Mysql过滤掉更多的行。</p>
<p>计算合适的前缀长度的一个办法是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。</p>
<p>前缀索引是一种能使索引更小、更快的有效方法，但另一方面也有缺点，MySql无法使用前缀索引做Order by 和 group by， 也无法使用前缀索引做覆盖扫描。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引不是一个单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式。但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，他的数据行实际上存放在索引的叶子页中。</p>
<p>因为无法同时把数据行放在两个不同的地方，所以一个表只能有一个聚簇索引</p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20210528115057532.png" alt="image-20210528115057532"></p>
<p>叶子页包含了行的全部数据，但是节点也只包含了索引列。</p>
<p>InnoDB将通过主键聚集数据。</p>
<p>如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，Innodb会隐式定义一个主键来作为聚簇索引。</p>
<p>聚簇索引的优点：</p>
<ul>
<li>可以把相关数据保存在一起</li>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取</li>
<li>使用覆盖索引扫描的查询时可以直接使用页节点中的主键值。</li>
</ul>
<p>聚簇索引的确定：</p>
<ul>
<li>插入速度严重依赖于插入顺序。如果按照主键的顺序插入是加载数据到InnoDB中速度最快的方式。如果不是按照主键顺序加载数据，那么在加载完成之后，最好用OPTIMIZE TABLE 命令重新组织下表</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者页分裂导致数据存储不连续的时候</li>
<li>二级索引可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找，而不是一次</li>
</ul>
<h4 id="InnoDB中按主键顺序插入的优缺点"><a href="#InnoDB中按主键顺序插入的优缺点" class="headerlink" title="InnoDB中按主键顺序插入的优缺点"></a>InnoDB中按主键顺序插入的优缺点</h4><p>优点:</p>
<ul>
<li>因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。避免了大量的页分裂和碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于高并发工作负载，在InnoDB中按照顺序插入可能会造成明显的争用。主键上的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制。</li>
</ul>
]]></content>
      <categories>
        <category>数据库 - MySQL</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现</title>
    <url>/2018/03/05/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Redis 设计与实现</p>
<span id="more"></span>

<h4 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h4><p>C语言的字符串不能满足Redis字符串在安全性，效率以及功能方面的要求</p>
<p>sds 的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sdshdr 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="comment">// 利用c99(C99 specification 6.7.2.1.16)中引入的 flexible array member,通过buf来引用sdshdr后面的地址，</span></span><br><span class="line">    <span class="comment">// 详情google &quot;flexible array member&quot;</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>free 属性值为0，表示这个sds没有分配任何未使用的空间</li>
<li>len 属性的值表示字符串的长度</li>
<li>buf 属性是一个char类型的数组，数组的最后一个字节保存空字符 ‘\0’</li>
</ul>
<blockquote>
<p>常数复杂度获取字符串长度</p>
</blockquote>
<p>C字符串不记录自身的长度信息，所以获取字符串的长度需要遍历整个字符串，复杂度为O（n）</p>
<p>因为SDS在len属性中记录了SDS本身的长度，所以获取sds长度的复杂度为O（1）</p>
<blockquote>
<p>空间预分配</p>
</blockquote>
<p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改并且需要对SDS进行空间扩展的时候，程序不仅会对SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间，通过预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数</p>
<ul>
<li>如果对SDS进行修改之后，SDS的长度（len属性的值）小于1M（宏SDS_MAX_PREALLOC），那么SDS len属 性的值和free属性的值将和free属性的值相同 举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1&#x3D;27字节（额外的一字节用于保存空字符）</li>
<li>如果SDS进行修改之后SDS的长度将大于等于1M，那么程序会分配1M未使用的空间，举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 对 sds 的 buf 进行扩展，扩展的长度不少于 addlen 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(</span></span><br><span class="line"><span class="params">    sds s,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> addlen   <span class="comment">// 需要增加的空间长度</span></span></span><br><span class="line"><span class="params">)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="type">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余空间可以满足需求，无须扩展</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前 buf 长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">// 新 buf 长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="comment">// #define SDS_MAX_PREALLOC (1024*1024)</span></span><br><span class="line">    <span class="comment">// 如果新 buf 长度小于 SDS_MAX_PREALLOC 长度</span></span><br><span class="line">    <span class="comment">// 那么将 buf 的长度设为新 buf 长度的两倍</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展长度</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>惰性空间释放</p>
</blockquote>
<p>当需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用</p>
<blockquote>
<p>SDS 优点</p>
</blockquote>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<h4 id="链表和链表节点"><a href="#链表和链表节点" class="headerlink" title="链表和链表节点"></a>链表和链表节点</h4><p>每个链表节点使用一个adlist.h&#x2F;listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个listNode通过prev和next指针组成双端链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头指针</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾指针</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 比对函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数</p>
<ul>
<li>dup函数复制链表节点时调用，用于复制链表节点所保存的值</li>
<li>free函数释放链表节点时调用，用于释放链表节点所保存的值</li>
<li>match函数在列表中查找和 key 匹配节点时调用，如果列表带有匹配器，那么匹配通过匹配器来进行。如果列表没有匹配器，那么直接将 key 和节点的值进行比对。</li>
</ul>
<p>Redis的链表实现的特性总结如下：</p>
<ul>
<li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</li>
<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</li>
<li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</li>
<li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)</li>
<li>多态：链表节点使用void * 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li>
</ul>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典，又称为符号表、关联数组或映射，用于保存键值对的抽象数据结构。在字典中，一个键可以和一个值进行关联（或者说将键映射为值），这些关联的键和值就称为键值对。</p>
<p>在字典中，一个键可以和一个值进行关联，这些关联的键和值就称之为键值对。</p>
<p>字典中的每个键都是唯一的。</p>
<blockquote>
<p>字典的实现</p>
</blockquote>
<p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<blockquote>
<p>哈希表</p>
</blockquote>
<p>Redis字典所使用的的哈希表由dict.h&#x2F;dictht结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）</span></span><br><span class="line">    dictEntry **table;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针数组的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针数组的长度掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 值总是等于size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表现有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     </span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>哈希表节点使用dictEntry结构表示，每个dictEntry结构保存一个键值对</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链往后继节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> </span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>key 保存键值对中的键，v 保存值，next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，用来解决键冲突的问题</p>
<p><img src="http://imgbed-wk.oss-cn-beijing.aliyuncs.com/img/image-20210802114749082.png" alt="image-20210802114749082"></p>
<blockquote>
<p>字典</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个字典使用两个哈希表，用于实现渐进式 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特定于类型的处理函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型处理函数的私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表（2个）</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 rehash 进度的标志，值为-1 表示 rehash 未进行</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">    <span class="type">int</span> iterators;      </span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type 属性和 privdata属性是针对不同类型的键值对，为创建多态字典而设置的</p>
<p>privdata属性保存了需要传给那些类型特定函数的可选参数</p>
<p>ht 属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下字典只使用ht[0]哈希表，ht[1]哈希表只会对ht[0]哈希表进行rehash时使用</p>
<blockquote>
<p>解决键冲突</p>
</blockquote>
<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引时，我们称这些键发生了冲突</p>
<p>Redis 的哈希表使用链地址法来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表链接起来，这样来解决冲突的问题</p>
<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p>整数集合是集合键的底层实现之一，一个集合中只包含整数值元素，并且元素数量不多时，Redis会使用整数集合键的底层实现，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素所使用的类型的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  </span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>contents的属性声明为int8_t类型的数组，但是实际上contents 数组中并不保存任何int8_t类型的值，contents数组的真正类型由encoding类型的值决定</p>
<ul>
<li><p>如果encoding属性的值为INTSET_ENC_INT16，那么数组里的每个项都是一个int16_t类型的整数值</p>
</li>
<li><p>如果encoding属性的值为INTSET_ENC_INT32，那么数组里的每个项都是一个int32_t类型的整数值</p>
</li>
<li><p>如果encoding属性的值为INTSET_ENC_INT64，那么数组里的每个项都是一个int64_t类型的整数值</p>
</li>
</ul>
<blockquote>
<p>升级</p>
</blockquote>
<p>每当我们要将一个新元素添加到整数集合中，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。</p>
<blockquote>
<p>降级</p>
</blockquote>
<p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表做列表键的底层实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush lst 1 3 5 666 <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; object encoding lst</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span></span><br></pre></td></tr></table></figure>

<p>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么是小整数值，要么是长度比较短的字符串，那么redis就会使用压缩列表来做哈希键的底层实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset profile <span class="string">&quot;name&quot;</span> <span class="string">&quot;wk&quot;</span> age 28 job php</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding profile</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis - 设计与实现</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2017/02/15/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>JavaScript 学习笔记</p>
<span id="more"></span>


<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>var 申明的变量的作用域</p>
<p>如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = x + <span class="number">2</span>; <span class="comment">// ReferenceError! 无法在函数体外引用变量x</span></span><br></pre></td></tr></table></figure>

<p>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行。</p>
<p>JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = x + <span class="number">1</span>; <span class="comment">// bar可以访问foo的变量x!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> z = y + <span class="number">1</span>; <span class="comment">// ReferenceError! foo不可以访问bar的变量y!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript的函数定义有个特点，会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，但是只会自动提升变量的声明，但不会提升变量的赋值。</p>
<p>我们在函数内部定义变量时，<strong>请严格遵守“在函数内部首先申明所有变量”这一规则</strong></p>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量实际上被绑定到<code>window</code>的一个属性：</p>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。</p>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>由于<code>var</code>和<code>let</code>申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var PI = 3.14;</span><br></pre></td></tr></table></figure>

<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line"><span class="variable constant_">PI</span>; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在一个对象中绑定函数，称为这个对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="property">age</span>; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br></pre></td></tr></table></figure>

<p>在一个方法内部，<code>this</code>是一个特殊变量，它始终指向当前对象，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>
<blockquote>
<p>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？</p>
</blockquote>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。</p>
<p>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。</p>
<p>在strict模式下函数的<code>this</code>指向<code>undefined</code>，因此，在strict模式下，你会得到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = xiaoming.<span class="property">age</span>;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>虽然在一个独立的函数调用中，根据是否是strict模式，<code>this</code>指向<code>undefined</code>或<code>window</code>，不过，我们还是可以控制<code>this</code>的指向的！</p>
<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>
<p>用<code>apply</code>修复<code>getAge()</code>调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 25</span></span><br><span class="line">getAge.<span class="title function_">apply</span>(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure>

<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><code>call()</code>把参数按顺序传入。</li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parseInt</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数英文叫Higher-order function。那么什么是高阶函数？</p>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(x) + <span class="title function_">f</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>再看reduce的用法。Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="variable">x1</span><span class="operator">,</span> <span class="variable">x2</span><span class="operator">,</span> <span class="variable">x3</span><span class="operator">,</span> <span class="variable">x4</span><span class="punctuation">]</span><span class="operator">.</span><span class="variable">reduce</span><span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">)</span> <span class="operator">=</span> <span class="variable">f</span><span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">x1</span><span class="operator">,</span> <span class="variable">x2</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">x3</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">x4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter也是一个常用的操作，它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。</p>
<p><code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看上去正常的结果:</span></span><br><span class="line">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>].<span class="title function_">sort</span>(); <span class="comment">// [&#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apple排在了最后:</span></span><br><span class="line">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>].<span class="title function_">sort</span>(); <span class="comment">// [&#x27;Google&#x27;, &#x27;Microsoft&quot;, &#x27;apple&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法理解的结果:</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].<span class="title function_">sort</span>(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure>

<p><code>Array</code>的<code>sort()</code>方法默认把所有元素先转换为String再排序，结果<code>&#39;10&#39;</code>排在了<code>&#39;2&#39;</code>的前面，因为字符<code>&#39;1&#39;</code>比字符<code>&#39;2&#39;</code>的ASCII码小。</p>
<p><code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p>
<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p><code>every()</code>方法可以判断数组的所有元素是否满足测试条件。</p>
<p>例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="property">length</span> &gt; <span class="number">0</span>;</span><br><span class="line">&#125;)); <span class="comment">// true, 因为每个元素都满足s.length&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">toLowerCase</span>() === s;</span><br><span class="line">&#125;)); <span class="comment">// false, 因为不是每个元素都全部是小写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find()</code>方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回<code>undefined</code></p>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p><code>findIndex()</code>和<code>find()</code>类似，也是查找符合条件的第一个元素，不同之处在于<code>findIndex()</code>会返回这个元素的索引，如果没有找到，返回<code>-1</code></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach()</code>和<code>map()</code>类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。<code>forEach()</code>常用于遍历数组，因此，传入的函数不需要返回值：</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数作为返回值，高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6标准新增的一种新的函数：箭头函数相当于匿名函数，并且简化了函数定义。</p>
<p>箭头函数有两种格式，一种像 <code>x =&gt; x * x</code> 的，只包含一个表达式，连<code>&#123; ... &#125;</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>&#123; ... &#125;</code>和<code>return</code>：如果参数不是一个，就需要用括号<code>()</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定 。箭头函数不会创建自己的<code>this,它只会从自己的作用域链的上一层继承this</code>。</p>
<h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><p>generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。</p>
<h3 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>
<p>要获取系统当前时间，用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.<span class="title function_">getFullYear</span>(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.<span class="title function_">getMonth</span>(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.<span class="title function_">getDate</span>(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.<span class="title function_">getDay</span>(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.<span class="title function_">getHours</span>(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.<span class="title function_">getMinutes</span>(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.<span class="title function_">getSeconds</span>(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.<span class="title function_">getMilliseconds</span>(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.<span class="title function_">getTime</span>(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript的月份范围用整数表示是0~11</strong></p>
<p>如果要创建一个指定日期和时间的<code>Date</code>对象，可以用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>

<h5 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h5><p><code>Date</code>对象表示的时间总是按浏览器所在时区显示的</p>
<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<p>JavaScript有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>);</span><br><span class="line"></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>切分字符串</p>
</blockquote>
<p>用正则表达式切分字符串比用固定的字符更灵活</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a b   c&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>分组</p>
</blockquote>
<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&#x27;010-12345&#x27;</span>); <span class="comment">// [&#x27;010-12345&#x27;, &#x27;010&#x27;, &#x27;12345&#x27;]</span></span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&#x27;010 12345&#x27;</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p>
<blockquote>
<p>贪婪匹配</p>
</blockquote>
<p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局搜索</p>
</blockquote>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var r1 = /test/g;</span><br><span class="line">// 等价于:</span><br><span class="line">var r2 = new RegExp(&#x27;test&#x27;, &#x27;g&#x27;);</span><br></pre></td></tr></table></figure>

<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&#x27;JavaScript&#x27;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&#x27;VBScript&#x27;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&#x27;JScript&#x27;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// [&#x27;ECMAScript&#x27;]</span></span><br><span class="line">re.<span class="property">lastIndex</span>; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">exec</span>(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure>

<p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配</p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。</p>
<p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</p>
<p>当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>
<blockquote>
<p>构造函数</p>
</blockquote>
<p>除了直接用<code>&#123; ... &#125;</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数，用关键字<code>new</code>来调用这个函数，并返回一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如<a href="http://www.jslint.com/">jslint</a>将可以帮你检测到漏写的<code>new</code></p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。</p>
<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。</p>
<p>Symbol 值也可以转为布尔值，但是不能转为数值。</p>
]]></content>
      <categories>
        <category>前端 - JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
